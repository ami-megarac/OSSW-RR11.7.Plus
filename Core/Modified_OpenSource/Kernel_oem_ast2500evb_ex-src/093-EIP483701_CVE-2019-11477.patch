diff -Naur linux.old/include/linux/tcp.h linux.new7/include/linux/tcp.h
--- linux.old/include/linux/tcp.h	2019-07-10 15:01:08.221734411 +0800
+++ linux.new7/include/linux/tcp.h	2019-07-10 15:08:19.603569988 +0800
@@ -383,4 +383,6 @@
 	return 0;
 }
 
+int tcp_skb_shift(struct sk_buff *to, struct sk_buff *from, int pcount,int shiftlen);
+
 #endif	/* _LINUX_TCP_H */
diff -Naur linux.old/include/net/tcp.h linux.new7/include/net/tcp.h
--- linux.old/include/net/tcp.h	2019-07-10 15:01:46.908868718 +0800
+++ linux.new7/include/net/tcp.h	2019-07-10 15:08:19.631569332 +0800
@@ -53,6 +53,8 @@
 
 #define MAX_TCP_HEADER	(128 + MAX_HEADER)
 #define MAX_TCP_OPTION_SPACE 40
+#define TCP_MIN_SND_MSS		48
+#define TCP_MIN_GSO_SIZE	(TCP_MIN_SND_MSS - MAX_TCP_OPTION_SPACE)
 
 /* 
  * Never offer a window over 32767 without using window scaling. Some
diff -Naur linux.old/net/ipv4/tcp.c linux.new7/net/ipv4/tcp.c
--- linux.old/net/ipv4/tcp.c	2019-07-10 15:02:08.124381311 +0800
+++ linux.new7/net/ipv4/tcp.c	2019-07-10 15:08:19.659568677 +0800
@@ -3045,7 +3045,8 @@
 	unsigned long limit;
 	int max_rshare, max_wshare, cnt;
 	unsigned int i;
-
+	
+	BUILD_BUG_ON(TCP_MIN_SND_MSS <= MAX_TCP_OPTION_SPACE);
 	BUILD_BUG_ON(sizeof(struct tcp_skb_cb) > sizeof(skb->cb));
 
 	percpu_counter_init(&tcp_sockets_allocated, 0);
diff -Naur linux.old/net/ipv4/tcp_input.c linux.new7/net/ipv4/tcp_input.c
--- linux.old/net/ipv4/tcp_input.c	2019-07-10 15:02:19.164115289 +0800
+++ linux.new7/net/ipv4/tcp_input.c	2019-07-10 15:08:19.671568396 +0800
@@ -1318,7 +1318,8 @@
 	TCP_SKB_CB(skb)->seq += shifted;
 
 	skb_shinfo(prev)->gso_segs += pcount;
-	BUG_ON(skb_shinfo(skb)->gso_segs < pcount);
+	//BUG_ON(skb_shinfo(skb)->gso_segs < pcount);
+	WARN_ON_ONCE(tcp_skb_pcount(skb) < pcount);
 	skb_shinfo(skb)->gso_segs -= pcount;
 
 	/* When we're adding to gso_segs == 1, gso_size will be zero,
@@ -1384,6 +1385,20 @@
 	return !skb_headlen(skb) && skb_is_nonlinear(skb);
 }
 
+int tcp_skb_shift(struct sk_buff *to, struct sk_buff *from,int pcount, int shiftlen)
+{
+	/* TCP min gso_size is 8 bytes (TCP_MIN_GSO_SIZE)
+	 * Since TCP_SKB_CB(skb)->tcp_gso_segs is 16 bits, we need
+	 * to make sure not storing more than 65535 * 8 bytes per skb,
+	 * even if current MSS is bigger.
+	 */
+	if (unlikely(to->len + shiftlen >= 65535 * TCP_MIN_GSO_SIZE))
+		return 0;
+	if (unlikely(tcp_skb_pcount(to) + pcount > 65535))
+		return 0;
+	return skb_shift(to, from, shiftlen);
+}
+
 /* Try collapsing SACK blocks spanning across multiple skbs to a single
  * skb.
  */
@@ -1395,6 +1410,7 @@
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct sk_buff *prev;
 	int mss;
+	int next_pcount;
 	int pcount = 0;
 	int len;
 	int in_sack;
@@ -1489,7 +1505,8 @@
 	if (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))
 		goto fallback;
 
-	if (!skb_shift(prev, skb, len))
+	//if (!skb_shift(prev, skb, len))
+	if (!tcp_skb_shift(prev, skb, pcount, len))
 		goto fallback;
 	if (!tcp_shifted_skb(sk, skb, state, pcount, len, mss, dup_sack))
 		goto out;
@@ -1508,9 +1525,13 @@
 		goto out;
 
 	len = skb->len;
-	if (skb_shift(prev, skb, len)) {
-		pcount += tcp_skb_pcount(skb);
-		tcp_shifted_skb(sk, skb, state, tcp_skb_pcount(skb), len, mss, 0);
+	//if (skb_shift(prev, skb, len)) {
+	//	pcount += tcp_skb_pcount(skb);
+	//	tcp_shifted_skb(sk, skb, state, tcp_skb_pcount(skb), len, mss, 0);
+	next_pcount = tcp_skb_pcount(skb);
+	if (tcp_skb_shift(prev, skb, next_pcount, len)) {
+		pcount += next_pcount;
+		tcp_shifted_skb(sk, skb, state, next_pcount, len, mss, 0);
 	}
 
 out:
diff -Naur linux.old/net/ipv4/tcp_output.c linux.new7/net/ipv4/tcp_output.c
--- linux.old/net/ipv4/tcp_output.c	2019-07-10 15:02:27.323918867 +0800
+++ linux.new7/net/ipv4/tcp_output.c	2019-07-10 15:08:19.679568209 +0800
@@ -1249,8 +1249,10 @@
 	mss_now -= icsk->icsk_ext_hdr_len;
 
 	/* Then reserve room for full set of TCP options and 8 bytes of data */
-	if (mss_now < 48)
-		mss_now = 48;
+	//if (mss_now < 48)
+	//	mss_now = 48;
+	if (mss_now < TCP_MIN_SND_MSS)
+		mss_now = TCP_MIN_SND_MSS;
 	return mss_now;
 }
 
