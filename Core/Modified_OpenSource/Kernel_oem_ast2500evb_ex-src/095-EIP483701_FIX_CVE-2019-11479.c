diff -Naur linux.old/Documentation/networking/ip-sysctl.txt linux.new/Documentation/networking/ip-sysctl.txt
--- linux.old/Documentation/networking/ip-sysctl.txt	2019-07-11 14:18:12.374414069 +0800
+++ linux.new/Documentation/networking/ip-sysctl.txt	2019-07-11 14:19:46.956328090 +0800
@@ -210,6 +210,13 @@
 	Path MTU discovery (MTU probing).  If MTU probing is enabled,
 	this is the initial MSS used by the connection.
 
+tcp_min_snd_mss - INTEGER
+	TCP SYN and SYNACK messages usually advertise an ADVMSS option,
+	as described in RFC 1122 and RFC 6691.
+	If this ADVMSS option is smaller than tcp_min_snd_mss,
+	it is silently capped to tcp_min_snd_mss.
+	Default : 48 (at least 8 bytes of payload per segment)
+
 tcp_congestion_control - STRING
 	Set the congestion control algorithm to be used for new
 	connections. The algorithm "reno" is always available, but
diff -Naur linux.old/include/net/tcp.h linux.new/include/net/tcp.h
--- linux.old/include/net/tcp.h	2019-07-11 14:50:01.819833589 +0800
+++ linux.new/include/net/tcp.h	2019-07-11 14:27:16.950342597 +0800
@@ -273,6 +273,7 @@
 extern int sysctl_tcp_tso_win_divisor;
 extern int sysctl_tcp_mtu_probing;
 extern int sysctl_tcp_base_mss;
+extern int sysctl_tcp_min_snd_mss;
 extern int sysctl_tcp_workaround_signed_windows;
 extern int sysctl_tcp_slow_start_after_idle;
 extern int sysctl_tcp_thin_linear_timeouts;
diff -Naur linux.old/net/ipv4/sysctl_net_ipv4.c linux.new/net/ipv4/sysctl_net_ipv4.c
--- linux.old/net/ipv4/sysctl_net_ipv4.c	2019-07-11 14:53:33.567092367 +0800
+++ linux.new/net/ipv4/sysctl_net_ipv4.c	2019-07-11 14:23:24.663507277 +0800
@@ -34,6 +34,8 @@
 static int ip_local_port_range_min[] = { 1, 1 };
 static int ip_local_port_range_max[] = { 65535, 65535 };
 static int tcp_adv_win_scale_min = -31;
+static int tcp_min_snd_mss_min = TCP_MIN_SND_MSS;
+static int tcp_min_snd_mss_max = 65535;
 static int tcp_adv_win_scale_max = 31;
 static int ip_ttl_min = 1;
 static int ip_ttl_max = 255;
@@ -615,6 +617,15 @@
 		.proc_handler	= proc_dointvec,
 	},
 	{
+		.procname	= "tcp_min_snd_mss",
+		.data		= &sysctl_tcp_min_snd_mss,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &tcp_min_snd_mss_min,
+		.extra2		= &tcp_min_snd_mss_max,
+	},
+	{
 		.procname	= "tcp_workaround_signed_windows",
 		.data		= &sysctl_tcp_workaround_signed_windows,
 		.maxlen		= sizeof(int),
diff -Naur linux.old/net/ipv4/tcp_output.c linux.new/net/ipv4/tcp_output.c
--- linux.old/net/ipv4/tcp_output.c	2019-07-11 14:23:57.850770506 +0800
+++ linux.new/net/ipv4/tcp_output.c	2019-07-11 14:25:22.248895030 +0800
@@ -61,6 +61,7 @@
 
 int sysctl_tcp_mtu_probing __read_mostly = 0;
 int sysctl_tcp_base_mss __read_mostly = TCP_BASE_MSS;
+int sysctl_tcp_min_snd_mss __read_mostly = TCP_MIN_SND_MSS;
 
 /* By default, RFC2861 behavior.  */
 int sysctl_tcp_slow_start_after_idle __read_mostly = 1;
@@ -1256,8 +1257,9 @@
 	/* Then reserve room for full set of TCP options and 8 bytes of data */
 	//if (mss_now < 48)
 	//	mss_now = 48;
-	if (mss_now < TCP_MIN_SND_MSS)
-		mss_now = TCP_MIN_SND_MSS;
+	//if (mss_now < TCP_MIN_SND_MSS)
+	//	mss_now = TCP_MIN_SND_MSS;
+	mss_now = max(mss_now, sysctl_tcp_min_snd_mss);
 	return mss_now;
 }
 
